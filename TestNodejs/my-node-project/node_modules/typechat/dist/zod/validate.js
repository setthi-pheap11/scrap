"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getZodSchemaAsTypeScript = exports.createZodJsonValidator = void 0;
const zod_1 = require("zod");
const result_1 = require("../result");
/**
 * Returns a JSON validator for a given Zod schema. The schema is supplied as an object where each property provides
 * a name for an associated Zod type. The `validate` method of the returned object validates a JSON object against the
 * supplied schema, the `getSchemaText` method obtains the TypeScript source text representation of the schema, and
 * the `getTypeName` method obtains the name of the given target type in the schema.
 * @param schema A schema object where each property provides a name for an associated Zod type.
 * @param targetType The name in the schema of the target type for JSON validation.
 * @returns A `TypeChatJsonValidator<z.TypeOf<T[K]>>`, where T is the schema and K is the target type name.
 */
function createZodJsonValidator(schema, typeName) {
    let schemaText;
    const validator = {
        getSchemaText: () => schemaText ??= getZodSchemaAsTypeScript(schema),
        getTypeName: () => typeName,
        validate
    };
    return validator;
    function validate(jsonObject) {
        const result = schema[typeName].safeParse(jsonObject);
        if (!result.success) {
            return (0, result_1.error)(result.error.issues.map(({ path, message }) => `${path.map(key => `[${JSON.stringify(key)}]`).join("")}: ${message}`).join("\""));
        }
        return (0, result_1.success)(result.data);
    }
}
exports.createZodJsonValidator = createZodJsonValidator;
function getTypeKind(type) {
    return type._def.typeName;
}
function getTypeIdentity(type) {
    switch (getTypeKind(type)) {
        case zod_1.z.ZodFirstPartyTypeKind.ZodObject:
            return type._def.shape();
        case zod_1.z.ZodFirstPartyTypeKind.ZodEnum:
            return type._def.values;
        case zod_1.z.ZodFirstPartyTypeKind.ZodUnion:
            return type._def.options;
    }
    return type;
}
function getTypePrecendece(type) {
    switch (getTypeKind(type)) {
        case zod_1.z.ZodFirstPartyTypeKind.ZodEnum:
        case zod_1.z.ZodFirstPartyTypeKind.ZodUnion:
        case zod_1.z.ZodFirstPartyTypeKind.ZodDiscriminatedUnion:
            return 0 /* TypePrecedence.Union */;
        case zod_1.z.ZodFirstPartyTypeKind.ZodIntersection:
            return 1 /* TypePrecedence.Intersection */;
    }
    return 2 /* TypePrecedence.Object */;
}
/**
 * Returns the TypeScript source code corresponding to a Zod schema. The schema is supplied as an object where each
 * property provides a name for an associated Zod type. The return value is a string containing the TypeScript source
 * code corresponding to the schema. Each property of the schema object is emitted as a named `interface` or `type`
 * declaration for the associated type and is referenced by that name in the emitted type declarations. Other types
 * referenced in the schema are emitted in their structural form.
 * @param schema A schema object where each property provides a name for an associated Zod type.
 * @returns The TypeScript source code corresponding to the schema.
 */
function getZodSchemaAsTypeScript(schema) {
    let result = "";
    let startOfLine = true;
    let indent = 0;
    const entries = Array.from(Object.entries(schema));
    let namedTypes = new Map(entries.map(([name, type]) => [getTypeIdentity(type), name]));
    for (const [name, type] of entries) {
        if (result) {
            appendNewLine();
        }
        const description = type._def.description;
        if (description) {
            for (const comment of description.split("\n")) {
                append(`// ${comment}`);
                appendNewLine();
            }
        }
        if (getTypeKind(type) === zod_1.z.ZodFirstPartyTypeKind.ZodObject) {
            append(`interface ${name} `);
            appendObjectType(type);
        }
        else {
            append(`type ${name} = `);
            appendTypeDefinition(type);
            append(";");
        }
        appendNewLine();
    }
    return result;
    function append(s) {
        if (startOfLine) {
            result += "    ".repeat(indent);
            startOfLine = false;
        }
        result += s;
    }
    function appendNewLine() {
        append("\n");
        startOfLine = true;
    }
    function appendType(type, minPrecedence = 0) {
        const name = namedTypes.get(getTypeIdentity(type));
        if (name) {
            append(name);
        }
        else {
            const parenthesize = getTypePrecendece(type) < minPrecedence;
            if (parenthesize)
                append("(");
            appendTypeDefinition(type);
            if (parenthesize)
                append(")");
        }
    }
    function appendTypeDefinition(type) {
        switch (getTypeKind(type)) {
            case zod_1.z.ZodFirstPartyTypeKind.ZodString:
                return append("string");
            case zod_1.z.ZodFirstPartyTypeKind.ZodNumber:
                return append("number");
            case zod_1.z.ZodFirstPartyTypeKind.ZodBoolean:
                return append("boolean");
            case zod_1.z.ZodFirstPartyTypeKind.ZodDate:
                return append("Date");
            case zod_1.z.ZodFirstPartyTypeKind.ZodUndefined:
                return append("undefined");
            case zod_1.z.ZodFirstPartyTypeKind.ZodNull:
                return append("null");
            case zod_1.z.ZodFirstPartyTypeKind.ZodUnknown:
                return append("unknown");
            case zod_1.z.ZodFirstPartyTypeKind.ZodArray:
                return appendArrayType(type);
            case zod_1.z.ZodFirstPartyTypeKind.ZodObject:
                return appendObjectType(type);
            case zod_1.z.ZodFirstPartyTypeKind.ZodUnion:
                return appendUnionOrIntersectionTypes(type._def.options, 0 /* TypePrecedence.Union */);
            case zod_1.z.ZodFirstPartyTypeKind.ZodDiscriminatedUnion:
                return appendUnionOrIntersectionTypes([...type._def.options.values()], 0 /* TypePrecedence.Union */);
            case zod_1.z.ZodFirstPartyTypeKind.ZodIntersection:
                return appendUnionOrIntersectionTypes(type._def.options, 1 /* TypePrecedence.Intersection */);
            case zod_1.z.ZodFirstPartyTypeKind.ZodTuple:
                return appendTupleType(type);
            case zod_1.z.ZodFirstPartyTypeKind.ZodRecord:
                return appendRecordType(type);
            case zod_1.z.ZodFirstPartyTypeKind.ZodLiteral:
                return appendLiteral(type._def.value);
            case zod_1.z.ZodFirstPartyTypeKind.ZodEnum:
                return append(type._def.values.map(value => JSON.stringify(value)).join(" | "));
            case zod_1.z.ZodFirstPartyTypeKind.ZodOptional:
                return appendUnionOrIntersectionTypes([type._def.innerType, zod_1.z.undefined()], 0 /* TypePrecedence.Union */);
            case zod_1.z.ZodFirstPartyTypeKind.ZodReadonly:
                return appendReadonlyType(type);
        }
        append("any");
    }
    function appendArrayType(arrayType) {
        appendType(arrayType._def.type, 2 /* TypePrecedence.Object */);
        append("[]");
    }
    function appendObjectType(objectType) {
        append("{");
        appendNewLine();
        indent++;
        for (let [name, type] of Object.entries(objectType._def.shape())) {
            const comment = type.description;
            append(name);
            if (getTypeKind(type) === zod_1.z.ZodFirstPartyTypeKind.ZodOptional) {
                append("?");
                type = type._def.innerType;
            }
            append(": ");
            appendType(type);
            append(";");
            if (comment)
                append(` // ${comment}`);
            appendNewLine();
        }
        indent--;
        append("}");
    }
    function appendUnionOrIntersectionTypes(types, minPrecedence) {
        let first = true;
        for (const type of types) {
            if (!first)
                append(minPrecedence === 1 /* TypePrecedence.Intersection */ ? " & " : " | ");
            appendType(type, minPrecedence);
            first = false;
        }
    }
    function appendTupleType(tupleType) {
        append("[");
        let first = true;
        for (let type of tupleType._def.items) {
            if (!first)
                append(", ");
            if (getTypeKind(type) === zod_1.z.ZodFirstPartyTypeKind.ZodOptional) {
                appendType(type._def.innerType, 2 /* TypePrecedence.Object */);
                append("?");
            }
            else {
                appendType(type);
            }
            first = false;
        }
        const rest = tupleType._def.rest;
        if (rest) {
            if (!first)
                append(", ");
            append("...");
            appendType(rest, 2 /* TypePrecedence.Object */);
            append("[]");
        }
        append("]");
    }
    function appendRecordType(recordType) {
        append("Record<");
        appendType(recordType._def.keyType);
        append(", ");
        appendType(recordType._def.valueType);
        append(">");
    }
    function appendLiteral(value) {
        append(typeof value === "string" || typeof value === "number" || typeof value === "boolean" ? JSON.stringify(value) : "any");
    }
    function appendReadonlyType(readonlyType) {
        append("Readonly<");
        appendType(readonlyType._def.innerType);
        append(">");
    }
}
exports.getZodSchemaAsTypeScript = getZodSchemaAsTypeScript;
