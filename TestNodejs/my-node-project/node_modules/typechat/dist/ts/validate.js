"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createTypeScriptJsonValidator = void 0;
const typescript_1 = __importDefault(require("typescript"));
const result_1 = require("../result");
const libText = `interface Array<T> { length: number, [n: number]: T }
interface Object { toString(): string }
interface Function { prototype: unknown }
interface CallableFunction extends Function {}
interface NewableFunction extends Function {}
interface String { readonly length: number }
interface Boolean { valueOf(): boolean }
interface Number { valueOf(): number }
interface RegExp { test(string: string): boolean }`;
/**
 * Returns a JSON validator for a given TypeScript schema. Validation is performed by an in-memory instance of
 * the TypeScript compiler. The specified type argument `T` must be the same type as `typeName` in the given `schema`.
 * @param schema A string containing the TypeScript source code for the JSON schema.
 * @param typeName The name of the JSON target type in the schema.
 * @returns A `TypeChatJsonValidator<T>` instance.
 */
function createTypeScriptJsonValidator(schema, typeName) {
    const options = {
        ...typescript_1.default.getDefaultCompilerOptions(),
        strict: true,
        skipLibCheck: true,
        noLib: true,
        types: []
    };
    const rootProgram = createProgramFromModuleText("");
    const validator = {
        getSchemaText: () => schema,
        getTypeName: () => typeName,
        createModuleTextFromJson,
        validate
    };
    return validator;
    function validate(jsonObject) {
        const moduleResult = validator.createModuleTextFromJson(jsonObject);
        if (!moduleResult.success) {
            return moduleResult;
        }
        const program = createProgramFromModuleText(moduleResult.data, rootProgram);
        const syntacticDiagnostics = program.getSyntacticDiagnostics();
        const programDiagnostics = syntacticDiagnostics.length ? syntacticDiagnostics : program.getSemanticDiagnostics();
        if (programDiagnostics.length) {
            const diagnostics = programDiagnostics.map(d => typeof d.messageText === "string" ? d.messageText : d.messageText.messageText).join("\n");
            return (0, result_1.error)(diagnostics);
        }
        return (0, result_1.success)(jsonObject);
    }
    function createModuleTextFromJson(jsonObject) {
        return (0, result_1.success)(`import { ${typeName} } from './schema';\nconst json: ${typeName} = ${JSON.stringify(jsonObject, undefined, 2)};\n`);
    }
    function createProgramFromModuleText(moduleText, oldProgram) {
        const fileMap = new Map([
            createFileMapEntry("/lib.d.ts", libText),
            createFileMapEntry("/schema.ts", schema),
            createFileMapEntry("/json.ts", moduleText)
        ]);
        const host = {
            getSourceFile: fileName => fileMap.get(fileName),
            getDefaultLibFileName: () => "lib.d.ts",
            writeFile: () => { },
            getCurrentDirectory: () => "/",
            getCanonicalFileName: fileName => fileName,
            useCaseSensitiveFileNames: () => true,
            getNewLine: () => "\n",
            fileExists: fileName => fileMap.has(fileName),
            readFile: fileName => "",
        };
        return typescript_1.default.createProgram(Array.from(fileMap.keys()), options, host, oldProgram);
    }
    function createFileMapEntry(filePath, fileText) {
        return [filePath, typescript_1.default.createSourceFile(filePath, fileText, typescript_1.default.ScriptTarget.Latest)];
    }
}
exports.createTypeScriptJsonValidator = createTypeScriptJsonValidator;
